{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n} // Note: $Shape is needed to make polymorphic withStyle refinements work correctly\n// It seems functions satisfy this type without $Shape\n// See: https://github.com/facebook/flow/issues/6784\n//\n//\n//\n//\n//\n//\n\n\nfunction driver(style, styletron) {\n  var tx = renderDeclarativeRules(style, styletron);\n  return styletron.renderStyle(tx);\n}\n\nfunction getInitialStyle() {\n  return {};\n}\n\nfunction renderDeclarativeRules(style, styletron) {\n  for (var key in style) {\n    var val = style[key];\n\n    if (key === \"animationName\" && typeof val !== \"string\") {\n      style.animationName = styletron.renderKeyframes(val);\n      continue;\n    }\n\n    if (key === \"fontFamily\" && typeof val !== \"string\") {\n      if (Array.isArray(val)) {\n        var result = \"\";\n\n        for (var _iterator = val, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var _font = _ref;\n\n          if (_typeof(_font) === \"object\") {\n            result += styletron.renderFontFace(_font) + \",\";\n          } else if (typeof _font === \"string\") {\n            result += _font + \",\";\n          }\n        }\n\n        style.fontFamily = result.slice(0, -1);\n        continue;\n      } else if (val === void 0) {\n        continue;\n      } else {\n        style.fontFamily = styletron.renderFontFace(val);\n        continue;\n      }\n    }\n\n    if (_typeof(val) === \"object\" && val !== null) {\n      renderDeclarativeRules(val, styletron);\n    }\n  }\n\n  return style;\n}\n\nexport { driver, getInitialStyle, renderDeclarativeRules };","map":{"version":3,"sources":["../src/index.js"],"names":["tx","renderDeclarativeRules","styletron","val","style","key","Array","result","font"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AA8BO,SAAA,MAAA,CAAA,KAAA,EAAA,SAAA,EAAuE;MACtEA,EAAAA,GAAKC,sBAAAA,CAAAA,KAAAA,EAAX,SAAWA,C;SACJC,SAAAA,CAAAA,WAAAA,CAAP,EAAOA,C;;;AAGF,SAAA,eAAA,GAAwC;SAC7C,E;;;AAGK,SAAA,sBAAA,CAAA,KAAA,EAAA,SAAA,EAGL;OACK,IAAL,G,IAAA,K,EAAyB;QACjBC,GAAAA,GAAMC,KAAAA,CAAZ,GAAYA,C;;QACRC,GAAAA,KAAAA,eAAAA,IAA2B,OAAA,GAAA,KAA/B,Q,EAAwD;YACtD,a,GAAsBH,SAAAA,CAAAA,eAAAA,CAAtB,GAAsBA,C;;;;QAGpBG,GAAAA,KAAAA,YAAAA,IAAwB,OAAA,GAAA,KAA5B,Q,EAAqD;UAC/CC,KAAAA,CAAAA,OAAAA,CAAJ,GAAIA,C,EAAoB;YAClBC,MAAAA,GAAJ,E;;6BACA,G,EAAA,QAAA,GAAA,KAAA,CAAA,OAAA,CAAA,SAAA,C,EAAA,EAAA,GAAA,C,EAAA,SAAA,GAAA,QAAA,GAAA,SAAA,GAAA,SAAA,CAAA,MAAA,CAAA,QAAA,CAAA,E,IAAwB;;;;;;;;;;;;cAAbC,KAAa,GAAA,I;;cAClB,OAAA,CAAA,KAAA,CAAA,KAAJ,Q,EAA8B;sBACfN,SAAAA,CAAAA,cAAAA,CAAb,KAAaA,IAAb,G;AADF,W,MAEO,IAAI,OAAA,KAAA,KAAJ,QAAA,EAA8B;sBACtBM,KAAb,GAAA,G;;;;cAGJ,U,GAAmBD,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAgB,CAAnC,CAAmBA,C;;AATrB,O,MAWO,IAAIJ,GAAAA,KAAQ,KAAZ,CAAA,EAAoB;;AAApB,OAAA,MAEA;cACL,U,GAAmBD,SAAAA,CAAAA,cAAAA,CAAnB,GAAmBA,C;;;;;QAInB,OAAA,CAAA,GAAA,CAAA,KAAA,QAAA,IAA2BC,GAAAA,KAA/B,I,EAA6C;6BAC3C,G,EAAA,S;;;;SAGJ,K","sourcesContent":["// @flow\n\nimport type {\n  Properties,\n  FontFace as FontFaceObject,\n  KeyframesObject,\n} from \"./style-types\";\n\nexport type {FontFaceObject, KeyframesObject};\n\n// Note: $Shape is needed to make polymorphic withStyle refinements work correctly\n// It seems functions satisfy this type without $Shape\n// See: https://github.com/facebook/flow/issues/6784\n//\n//\n//\n//\n//\n//\nexport type StyleObject = $Shape<{\n  ...Properties,\n  [string]: StyleObject, // Unrecognized properties are assumed to be media queries or pseudo selectors w/ nested style object. See: https://github.com/styletron/styletron-standard\n}>;\n\nexport interface StandardEngine {\n  renderStyle(style: StyleObject): string;\n  renderKeyframes(keyframes: KeyframesObject): string;\n  renderFontFace(fontFace: FontFaceObject): string;\n}\n\nexport function driver(style: StyleObject, styletron: StandardEngine): string {\n  const tx = renderDeclarativeRules(style, styletron);\n  return styletron.renderStyle(tx);\n}\n\nexport function getInitialStyle(): StyleObject {\n  return {};\n}\n\nexport function renderDeclarativeRules(\n  style: StyleObject,\n  styletron: StandardEngine,\n) {\n  for (const key in style) {\n    const val = style[key];\n    if (key === \"animationName\" && typeof val !== \"string\") {\n      style.animationName = styletron.renderKeyframes((val: any));\n      continue;\n    }\n    if (key === \"fontFamily\" && typeof val !== \"string\") {\n      if (Array.isArray(val)) {\n        let result = \"\";\n        for (const font of val) {\n          if (typeof font === \"object\") {\n            result += `${styletron.renderFontFace((font: any))},`;\n          } else if (typeof font === \"string\") {\n            result += `${font},`;\n          }\n        }\n        style.fontFamily = result.slice(0, -1);\n        continue;\n      } else if (val === void 0) {\n        continue;\n      } else {\n        style.fontFamily = styletron.renderFontFace((val: any));\n        continue;\n      }\n    }\n    if (typeof val === \"object\" && val !== null) {\n      renderDeclarativeRules(val, styletron);\n    }\n  }\n  return style;\n}\n"]},"metadata":{},"sourceType":"module"}